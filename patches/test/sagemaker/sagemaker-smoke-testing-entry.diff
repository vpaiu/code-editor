Index: code-editor-src/test/automation/src/playwrightBrowser.ts
===================================================================
--- code-editor-src.orig/test/automation/src/playwrightBrowser.ts
+++ code-editor-src/test/automation/src/playwrightBrowser.ts
@@ -18,7 +18,16 @@ let port = 9000;
 
 export async function launch(options: LaunchOptions): Promise<{ serverProcess: ChildProcess; driver: PlaywrightDriver }> {
 
-	// Launch server
+	// For SageMaker: skip server launch and navigate via DataZone
+	if (process.env.VSCODE_REMOTE_SERVER_PATH && process.env.DATAZONE_URL && process.env.SPACE_NAME) {
+		const { browser, context, page, pageLoadedPromise } = await launchCodeEditorInSageMaker(options);
+		return {
+			serverProcess: null as any, // No server process for SageMaker
+			driver: new PlaywrightDriver(browser, context, page, null as any, pageLoadedPromise, options)
+		};
+	}
+
+	// Launch server (original flow)
 	const { serverProcess, endpoint } = await launchServer(options);
 
 	// Launch browser
@@ -100,7 +109,7 @@ async function launchBrowser(options: La
 	browser.on('disconnected', () => logger.log(`Playwright: browser disconnected`));
 
 	const context = await measureAndLog(() => browser.newContext(), 'browser.newContext', logger);
-
+	
 	if (tracing) {
 		try {
 			await measureAndLog(() => context.tracing.start({ screenshots: true, snapshots }), 'context.tracing.start()', logger);
@@ -149,6 +158,144 @@ async function launchBrowser(options: La
 	return { browser, context, page, pageLoadedPromise };
 }
 
+async function launchCodeEditorInSageMaker(options: LaunchOptions) {
+	const { logger, tracing, snapshots, headless } = options;
+	const datazoneUrl = process.env.DATAZONE_URL!;
+	const spaceName = process.env.SPACE_NAME!;
+
+	const [browserType, browserChannel] = (options.browser ?? 'chromium').split('-');
+	const browser = await measureAndLog(() => playwright[browserType as unknown as 'chromium' | 'webkit' | 'firefox'].launch({
+		headless: headless ?? false,
+		timeout: 0,
+		channel: browserChannel,
+	}), 'playwright#launch', logger);
+
+	browser.on('disconnected', () => logger.log(`Playwright: browser disconnected`));
+
+	const context = await measureAndLog(() => browser.newContext(), 'browser.newContext', logger);
+	
+	if (tracing) {
+		try {
+			await measureAndLog(() => context.tracing.start({ screenshots: true, snapshots }), 'context.tracing.start()', logger);
+		} catch (error) {
+			logger.log(`Playwright (Browser): Failed to start playwright tracing (${error})`);
+		}
+	}
+	
+	let page = await measureAndLog(() => context.newPage(), 'context.newPage()', logger);
+	await measureAndLog(() => page.setViewportSize({ width: 1200, height: 800 }), 'page.setViewportSize', logger);
+	
+	if (options.verbose) {
+		context.on('page', () => logger.log(`Playwright (Browser): context.on('page')`));
+		context.on('requestfailed', e => logger.log(`Playwright (Browser): context.on('requestfailed') [${e.failure()?.errorText} for ${e.url()}]`));
+		
+		page.on('console', e => logger.log(`Playwright (Browser): window.on('console') [${e.text()}]`));
+		page.on('dialog', () => logger.log(`Playwright (Browser): page.on('dialog')`));
+		page.on('domcontentloaded', () => logger.log(`Playwright (Browser): page.on('domcontentloaded')`));
+		page.on('load', () => logger.log(`Playwright (Browser): page.on('load')`));
+		page.on('popup', () => logger.log(`Playwright (Browser): page.on('popup')`));
+		page.on('framenavigated', () => logger.log(`Playwright (Browser): page.on('framenavigated')`));
+		page.on('requestfailed', e => logger.log(`Playwright (Browser): page.on('requestfailed') [${e.failure()?.errorText} for ${e.url()}]`));
+	}
+	
+	page.on('pageerror', async (error) => logger.log(`Playwright (Browser) ERROR: page error: ${error}`));
+	page.on('crash', () => logger.log('Playwright (Browser) ERROR: page crash'));
+	page.on('close', () => logger.log('Playwright (Browser): page close'));
+	page.on('response', async (response) => {
+		if (response.status() >= 400) {
+			logger.log(`Playwright (Browser) ERROR: HTTP status ${response.status()} for ${response.url()}`);
+		}
+	});
+
+	// Navigate to DataZone and authenticate
+	logger.log(`Authenticating through DataZone: ${datazoneUrl}`);
+	await page.goto(datazoneUrl, { waitUntil: 'networkidle' });
+
+	// Handle SSO login if credentials are provided
+	if (process.env.SSO_USERNAME && process.env.SSO_PASSWORD) {
+		logger.log('Performing SSO login...');
+		
+		// Click SSO button
+		await page.click('button:has-text("Sign in with SSO"), button:has-text("SSO"), a:has-text("Sign in with SSO")');
+		await page.waitForLoadState('networkidle', { timeout: 30000 });
+		
+		// Fill username
+		await page.waitForSelector('#awsui-input-0', { timeout: 30000 });
+		await page.fill('#awsui-input-0', process.env.SSO_USERNAME);
+		
+		// Click Next
+		await page.click('button:has-text("Next"), button[type="submit"]');
+		await page.waitForLoadState('networkidle', { timeout: 30000 });
+		
+		// Fill password
+		await page.waitForSelector('input[name="password"], input[type="password"], #password', { timeout: 30000 });
+		await page.fill('input[name="password"], input[type="password"], #password', process.env.SSO_PASSWORD);
+		
+		// Click login
+		await page.click('button[type="submit"], input[type="submit"], button:has-text("Sign in"), button:has-text("Login")');
+		await page.waitForLoadState('networkidle', { timeout: 60000 });
+	}
+
+	// Wait for Compute heading and click space
+	await page.waitForSelector('h2:has-text("Compute")', { timeout: 60000 });
+	logger.log(`Opening space: ${spaceName}`);
+	
+	// Wait for new page to open when clicking the space button
+	const [newPage] = await Promise.all([
+		context.waitForEvent('page'),
+		page.click(`[data-id="${spaceName}"] button[data-testid="space-open-button"]`)
+	]);
+	
+	// Switch to the new Code Editor page
+	await newPage.waitForLoadState('networkidle', { timeout: 60000 });
+	logger.log(`Switched to Code Editor page: ${newPage.url()}`);
+	
+	// Switch page reference to the new Code Editor window
+	page = newPage;
+	
+	// Wait for Code Editor to fully load
+	await page.waitForTimeout(10000);
+	const currentUrl1 = page.url();
+	const workspacePath1 = '/home/sagemaker-user';
+	const baseUrl1 = currentUrl1.split('?')[0];
+	const finalUrl1 = `${baseUrl1}?folder=${URI.file(workspacePath1).path}`;
+	await page.goto(finalUrl1, { waitUntil: 'networkidle' });
+	
+	// Set up test workspace in SageMaker by cloning the test repo
+	logger.log('Setting up test workspace in SageMaker...');
+	
+	// Open integrated terminal
+	await page.waitForTimeout(10000);
+	await page.keyboard.press('Control+Shift+`');
+	await page.waitForSelector('.terminal', { timeout: 30000 });
+	
+	// Clone the test repository to home directory (if not exists)
+	await page.keyboard.type('cd /home/sagemaker-user && [ ! -d "vscode-smoketest-express" ] && git clone https://github.com/microsoft/vscode-smoketest-express.git || echo "Directory exists"');
+	await page.keyboard.press('Enter');
+	
+	// Wait for clone to complete
+	await page.waitForTimeout(10000);
+	
+	// Navigate to workspace with payload parameters (like launchBrowser)
+	const payloadParam = `[${[
+		'["enableProposedApi",""]',
+		'["skipWelcome", "true"]',
+		'["skipReleaseNotes", "true"]',
+		`["logLevel","${options.verbose ? 'trace' : 'info'}"]`
+	].join(',')}]`;
+	
+	const currentUrl = page.url();
+	const workspacePath = '/home/sagemaker-user/vscode-smoketest-express';
+	const baseUrl = currentUrl.split('?')[0];
+	const finalUrl = `${baseUrl}?folder=${URI.file(workspacePath).path}&payload=${payloadParam}`;
+	await page.goto(finalUrl, { waitUntil: 'networkidle' });
+	
+	logger.log(`Successfully opened SageMaker Code Editor space: ${spaceName}`);
+
+	const pageLoadedPromise = page.waitForLoadState('load');
+	return { browser, context, page, pageLoadedPromise };
+}
+
 function waitForEndpoint(server: ChildProcess, logger: Logger): Promise<string> {
 	return new Promise<string>((resolve, reject) => {
 		let endpointFound = false;
Index: code-editor-src/test/smoke/src/main.ts
===================================================================
--- code-editor-src.orig/test/smoke/src/main.ts
+++ code-editor-src/test/smoke/src/main.ts
@@ -5,16 +5,9 @@
 
 import * as fs from 'fs';
 import { gracefulify } from 'graceful-fs';
-import * as cp from 'child_process';
 import * as path from 'path';
-import * as os from 'os';
 import * as minimist from 'minimist';
-import * as rimraf from 'rimraf';
-import * as vscodetest from '@vscode/test-electron';
-import fetch from 'node-fetch';
-import { Quality, MultiLogger, Logger, ConsoleLogger, FileLogger, measureAndLog, getDevElectronPath, getBuildElectronPath, getBuildVersion } from '../../automation';
-import { retry, timeout } from './utils';
-
+import { Quality, MultiLogger, Logger, ConsoleLogger, FileLogger, getDevElectronPath, getBuildElectronPath, getBuildVersion } from '../../automation';
 import { setup as setupDataLossTests } from './areas/workbench/data-loss.test';
 import { setup as setupPreferencesTests } from './areas/preferences/preferences.test';
 import { setup as setupSearchTests } from './areas/search/search.test';
@@ -118,23 +111,10 @@ try {
 	logger.log(`Error enabling graceful-fs: ${error}`);
 }
 
-const testDataPath = path.join(os.tmpdir(), 'vscsmoke');
-if (fs.existsSync(testDataPath)) {
-	rimraf.sync(testDataPath);
-}
-fs.mkdirSync(testDataPath, { recursive: true });
-process.once('exit', () => {
-	try {
-		rimraf.sync(testDataPath);
-	} catch {
-		// noop
-	}
-});
+const testDataPath = '/home/sagemaker-user';
 
-const testRepoUrl = 'https://github.com/microsoft/vscode-smoketest-express';
 const workspacePath = path.join(testDataPath, 'vscode-smoketest-express');
 const extensionsPath = path.join(testDataPath, 'extensions-dir');
-fs.mkdirSync(extensionsPath, { recursive: true });
 
 function fail(errorMessage): void {
 	logger.log(errorMessage);
@@ -211,7 +191,10 @@ else {
 	const testCodeServerPath = opts.build || process.env.VSCODE_REMOTE_SERVER_PATH;
 
 	if (typeof testCodeServerPath === 'string') {
-		if (!fs.existsSync(testCodeServerPath)) {
+		// Skip file existence check for SageMaker/DataZone testing
+		if (process.env.DATAZONE_URL && process.env.SPACE_NAME) {
+			logger.log(`Running web smoke tests against SageMaker DataZone space: ${process.env.SPACE_NAME}`);
+		} else if (!fs.existsSync(testCodeServerPath)) {
 			fail(`Cannot find Code server at ${testCodeServerPath}.`);
 		} else {
 			logger.log(`Running web smoke tests against ${testCodeServerPath}`);
@@ -233,121 +216,6 @@ logger.log(`VS Code product quality: ${q
 
 const userDataDir = path.join(testDataPath, 'd');
 
-async function setupRepository(): Promise<void> {
-	if (opts['test-repo']) {
-		logger.log('Copying test project repository:', opts['test-repo']);
-		rimraf.sync(workspacePath);
-		// not platform friendly
-		if (process.platform === 'win32') {
-			cp.execSync(`xcopy /E "${opts['test-repo']}" "${workspacePath}"\\*`);
-		} else {
-			cp.execSync(`cp -R "${opts['test-repo']}" "${workspacePath}"`);
-		}
-	} else {
-		if (!fs.existsSync(workspacePath)) {
-			logger.log('Cloning test project repository...');
-			const res = cp.spawnSync('git', ['clone', testRepoUrl, workspacePath], { stdio: 'inherit' });
-			if (!fs.existsSync(workspacePath)) {
-				throw new Error(`Clone operation failed: ${res.stderr.toString()}`);
-			}
-		} else {
-			logger.log('Cleaning test project repository...');
-			cp.spawnSync('git', ['fetch'], { cwd: workspacePath, stdio: 'inherit' });
-			cp.spawnSync('git', ['reset', '--hard', 'FETCH_HEAD'], { cwd: workspacePath, stdio: 'inherit' });
-			cp.spawnSync('git', ['clean', '-xdf'], { cwd: workspacePath, stdio: 'inherit' });
-		}
-	}
-}
-
-async function ensureStableCode(): Promise<void> {
-	let stableCodePath = opts['stable-build'];
-	if (!stableCodePath) {
-		const current = parseVersion(version!);
-		const versionsReq = await retry(() => measureAndLog(() => fetch('https://update.code.visualstudio.com/api/releases/stable'), 'versionReq', logger), 1000, 20);
-
-		if (!versionsReq.ok) {
-			throw new Error('Could not fetch releases from update server');
-		}
-
-		const versions: string[] = await measureAndLog(() => versionsReq.json(), 'versionReq.json()', logger);
-		const stableVersion = versions.find(raw => {
-			const version = parseVersion(raw);
-			return version.major < current.major || (version.major === current.major && version.minor < current.minor);
-		});
-
-		if (!stableVersion) {
-			throw new Error(`Could not find suitable stable version for ${version}`);
-		}
-
-		logger.log(`Found VS Code v${version}, downloading previous VS Code version ${stableVersion}...`);
-
-		let lastProgressMessage: string | undefined = undefined;
-		let lastProgressReportedAt = 0;
-		const stableCodeDestination = path.join(testDataPath, 's');
-		const stableCodeExecutable = await retry(() => measureAndLog(() => vscodetest.download({
-			cachePath: stableCodeDestination,
-			version: stableVersion,
-			extractSync: true,
-			reporter: {
-				report: report => {
-					let progressMessage = `download stable code progress: ${report.stage}`;
-					const now = Date.now();
-					if (progressMessage !== lastProgressMessage || now - lastProgressReportedAt > 10000) {
-						lastProgressMessage = progressMessage;
-						lastProgressReportedAt = now;
-
-						if (report.stage === 'downloading') {
-							progressMessage += ` (${report.bytesSoFar}/${report.totalBytes})`;
-						}
-
-						logger.log(progressMessage);
-					}
-				},
-				error: error => logger.log(`download stable code error: ${error}`)
-			}
-		}), 'download stable code', logger), 1000, 3, () => new Promise<void>((resolve, reject) => {
-			rimraf(stableCodeDestination, { maxBusyTries: 10 }, error => {
-				if (error) {
-					reject(error);
-				} else {
-					resolve();
-				}
-			});
-		}));
-
-		if (process.platform === 'darwin') {
-			// Visual Studio Code.app/Contents/MacOS/Electron
-			stableCodePath = path.dirname(path.dirname(path.dirname(stableCodeExecutable)));
-		} else {
-			// VSCode/Code.exe (Windows) | VSCode/code (Linux)
-			stableCodePath = path.dirname(stableCodeExecutable);
-		}
-
-		opts['stable-version'] = parseVersion(stableVersion);
-	}
-
-	if (!fs.existsSync(stableCodePath)) {
-		throw new Error(`Cannot find Stable VSCode at ${stableCodePath}.`);
-	}
-
-	logger.log(`Using stable build ${stableCodePath} for migration tests`);
-
-	opts['stable-build'] = stableCodePath;
-}
-
-async function setup(): Promise<void> {
-	logger.log('Test data path:', testDataPath);
-	logger.log('Preparing smoketest setup...');
-
-	if (!opts.web && !opts.remote && opts.build) {
-		// only enabled when running with --build and not in web or remote
-		await measureAndLog(() => ensureStableCode(), 'ensureStableCode', logger);
-	}
-	await measureAndLog(() => setupRepository(), 'setupRepository', logger);
-
-	logger.log('Smoketest setup done!\n');
-}
-
 // Before all tests run setup
 before(async function () {
 	this.timeout(5 * 60 * 1000); // increase since we download VSCode
@@ -371,31 +239,6 @@ before(async function () {
 		extraArgs: (opts.electronArgs || '').split(' ').map(arg => arg.trim()).filter(arg => !!arg)
 	};
 
-	await setup();
-});
-
-// After main suite (after all tests)
-after(async function () {
-	try {
-		let deleted = false;
-		await measureAndLog(() => Promise.race([
-			new Promise<void>((resolve, reject) => rimraf(testDataPath, { maxBusyTries: 10 }, error => {
-				if (error) {
-					reject(error);
-				} else {
-					deleted = true;
-					resolve();
-				}
-			})),
-			timeout(30000).then(() => {
-				if (!deleted) {
-					throw new Error('giving up after 30s');
-				}
-			})
-		]), 'rimraf(testDataPath)', logger);
-	} catch (error) {
-		logger.log(`Unable to delete smoke test workspace: ${error}. This indicates some process is locking the workspace folder.`);
-	}
 });
 
 describe(`VSCode Smoke Tests (${opts.web ? 'Web' : 'Electron'})`, () => {
Index: code-editor-src/test/automation/src/code.ts
===================================================================
--- code-editor-src.orig/test/automation/src/code.ts
+++ code-editor-src/test/automation/src/code.ts
@@ -88,7 +88,9 @@ export async function launch(options: La
 	// Browser smoke tests
 	if (options.web) {
 		const { serverProcess, driver } = await measureAndLog(() => launchPlaywrightBrowser(options), 'launch playwright (browser)', options.logger);
-		registerInstance(serverProcess, options.logger, 'server');
+		if (serverProcess) {
+			registerInstance(serverProcess, options.logger, 'server');
+		}
 
 		return new Code(driver, options.logger, serverProcess, undefined, options.quality, options.version);
 	}
@@ -109,7 +111,7 @@ export class Code {
 	constructor(
 		driver: PlaywrightDriver,
 		readonly logger: Logger,
-		private readonly mainProcess: cp.ChildProcess,
+		private readonly mainProcess: cp.ChildProcess | null,
 		private readonly safeToKill: Promise<void> | undefined,
 		readonly quality: Quality,
 		readonly version: { major: number; minor: number; patch: number }
@@ -155,6 +157,13 @@ export class Code {
 
 	async exit(): Promise<void> {
 		return measureAndLog(() => new Promise<void>(resolve => {
+			// For SageMaker (no server process), just close driver and resolve
+			if (!this.mainProcess) {
+				this.driver.close();
+				resolve();
+				return;
+			}
+
 			const pid = this.mainProcess.pid!;
 
 			let done = false;
